\documentclass{article}

\usepackage[table,xcdraw]{xcolor}
\usepackage{float}
\usepackage[euler]{textgreek}
\usepackage{fancyhdr}
\pagestyle{fancy}

\title{Parallel Orbital Simulation Environment (POSE)}
\author{Dylan R. Wagner}

\begin{document}

  \pagenumbering{gobble}
  \maketitle
  
  \section{Context}
  
  This document will describe the aspects of the simulation software including: operation, orbital model including models of perturbing forces, concurrent parallel design, input and output, model of orbital collisions and simulation of spacecraft logic. Additional aspects related to stages of simulation development will also be provided.
  
  \section{Summary of Operation}
  
  \paragraph{1)}
  
  The software is to take in parameters relating to the simulation environment. Read in the initial input file defining the state of objects in orbit at time 0. These objects will be added alongside entities pertaining to the orbital environment such as the Earth, Moon, Sun and other “Smart” objects. 
  
  \paragraph{2)}
  
  The simulation will then calculate acceleration vectors for each object in the environment then update the corresponding velocity vector and position. For “Smart” objects, custom logic evaluates the environment within the simulation then updates internal state. When the simulation has completed calculations for the current time interval, collision detection and modeling is evaluated. Any new bodies generated by the collision detection and modeling algorithm will be added to the current pool of bodies in the simulation. At this point, the current state of the bodies in the simulation will be logged to a file.
  
  \paragraph{3)}
  
  From this point on, the simulation repeats until a stop condition is reached. This stop condition is tied to the total runtime or triggered by defined event(s) within the simulation. At the end of simulation statics will be logged to a flat file.
  
  \section{Orbital Simulation Method}
  
  The simulation software will use Cowell’s method. Cowell’s method involves adding together acceleration vectors acting on bodies in orbit. This summed acceleration vector can be separated in X, Y, Z components then integrated to find velocity with velocity being integrated to find spacial displacement. 
  
  \section{Models of Perturbing Forces}
  
  \begin{itemize}
  	\item Large Body Gravity
  	\item Earth Non-spherical Gravity
  	\item Solar Radiation
  	\item Drag
  	\item Magnetic Fields
  	\item Propulsion
  \end{itemize}
  
  
  \section{GPU Acceleration}
  
Most calculations on bodies within the simulation will be accelerated by one or many graphic processing units. Calculations pertaining to the orbital perturbations will be at the heart of the shader program. It is important to note that not all calculations will be performed on the GPU but the bulk will. By using GPU acceleration, massive amount of orbital debris can be included into the simulation. Using GPU acceleration the simulation can scale by using multiple GPUs.

\bigskip
\noindent
Bindings for Vulkan devloped under the Vulkano project for the Rust language should be used for calculations on objects within the simulation. Vulkan provides a cross operating system graphics API implemented by common graphic processing unit vendors.
  
  \section{Input and Output}
  
The input and output to the simulation will consist of only text based files or streams. Below definitions for all input and output at all stages of the simulation are provided. 
  
  \subsection{Input at Start-up}
  
  The simulation at startup needs some information pertaining the celestial environment. This information consists of the bodies which will be simulated. The bodies are ether debris or spacecraft; each needing additional attributes which define the object. Below attributes for both debris and spacecraft are listed:
  
  \paragraph{Debris}
  \begin{itemize}
  	\item ID (Unique)
  	\item X, Y, Z (Geocentric) locations in the simulation space
  	\item X, Y, Z (Geocentric) initial velocity values
  	\item Shape (Cube or Spheroid)
  	\item Dimensions W, L, H
  	\item Material (Eg: Aluminum or Aluminium oxide)
  \end{itemize}
  
  \paragraph{Spacecraft}
  \begin{itemize}
    	\item ID (Unique)
    	\item Spacecraft Name
    	\item Orientation (\textalpha, \textbeta, \textgamma)
  	\item X, Y, Z (Geocentric) locations in the simulation space
  	\item X, Y, Z (Geocentric) initial velocity values
  	\item Opt01a: Shape (Cube or Spheroid)
  	\item Opt01a: Dimensions W, L, H
  	\item Opt02b: Spacecraft model file
  \end{itemize}
  
  The objects read in at start up will be listed sequentially in a flat file using Javascript Object Notation (JSON).
  
  \subsection{Simulation Output}
  
	The simulation will produce results throughout the simulation and at simulation stop condition. The simulation will be constantly writing to the Object Data file defined below. At simulation stop, a summary file will be provided containing information on majors events occurred. 
  
  \paragraph{Object Data}
  
  The simulation will produce a comma separated value string file containing data ordered by location then time. The name of this output file is supplied by the user at simulation start. The format is provided below:
  
  \begin{verbatim}
  	ID,Time,X,Y,Z,vX,vY,vZ
  	
  	ID - Integer value
  	Time - String ISO Format (YYYYMMDDThh:mm:ss.sssZ)
  	X,Y,Z - Double precision value in format "%.6f" with unit m
  	vX,vY,vZ - Double precision value in format "%.6f" with unit m/s  	
  	
  \end{verbatim}
  
  \paragraph{Simulation Summary}
  
  \section{Environment}  
  
  \subsection{Coordinate System}
  
  \subsection{Solar - Planetary Interactions}
   
  \section{Model of Orbital Collisions}
  
  \section{Simulation of Spacecraft Logic}
  
  \section{Stages of Development}
  
  \section{Domain}
  
  
\end{document}